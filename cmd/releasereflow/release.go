// Copyright 2017 GRAIL, Inc. All rights reserved.
// Use of this source code is governed by the Apache 2.0
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/build"
	"html/template"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"time"
)

var (
	vflag     = flag.Bool("v", false, "print subcommand output")
	reflow    = flag.String("reflow", "github.com/grailbio/reflow/cmd/reflow", "reflow go get path")
	reflowlet = flag.String("reflowlet", "github.com/grailbio/reflow/cmd/reflowlet", "reflowlet go get path")
	repo      = flag.String("repo", "grailbio/reflowlet", "docker repository")
)

func usage() {
	fmt.Fprintf(os.Stderr, `usage: releasereflow version

Releasereflow builds a new reflowlet, pushes it to the reflowlet
Docker repository, and then emits the corresponding version.go file
in command reflow's package directory.
`)
	flag.PrintDefaults()
	os.Exit(2)
}

func main() {
	flag.Usage = usage
	flag.Parse()
	if flag.NArg() != 1 {
		flag.Usage()
	}
	version := flag.Arg(0)
	dir, err := ioutil.TempDir("", "reflow")
	if err != nil {
		log.Fatal(err)
	}
	defer os.RemoveAll(dir)

	reflowletPath := filepath.Join(dir, "reflowlet")
	cmd := command("go", "build", "-ldflags", fmt.Sprintf("-X main.version=%s", version), "-o", reflowletPath, *reflowlet)
	log.Printf("command: %v", cmd)
	cmd.Env = os.Environ()
	cmd.Env = append(cmd.Env, "GOOS=linux")
	cmd.Env = append(cmd.Env, "GOARCH=amd64")
	log.Printf("building reflowlet")
	if err := cmd.Run(); err != nil {
		log.Fatalf("build reflowlet: %v", err)
	}
	const dockerfile = `FROM frolvlad/alpine-glibc
COPY reflowlet /reflowlet
ENTRYPOINT ["/reflowlet"]
`
	dockerfilePath := filepath.Join(dir, "Dockerfile")
	if err := ioutil.WriteFile(dockerfilePath, []byte(dockerfile), 0666); err != nil {
		log.Fatal(err)
	}
	// For some reason, Docker fails to find the reflowlet binary if we
	// give it an absolute path. Instead, change into the temporary
	// directory and build from there. (This happens on a Mac.)
	if err := os.Chdir(dir); err != nil {
		log.Fatal(err)
	}
	image := fmt.Sprintf("%s:%d", *repo, time.Now().Unix())
	cmd = command("docker", "build", "-t", image, dir)
	log.Printf("building reflowlet docker image")
	if err := cmd.Run(); err != nil {
		log.Fatalf("build reflowlet image: %v", err)
	}
	cmd = command("docker", "push", image)
	log.Printf("pushing image to %s", image)
	if err := cmd.Run(); err != nil {
		log.Fatalf("push reflowlet image: %v", err)
	}
	pkg, err := build.Default.Import(*reflow, "", build.FindOnly)
	if err != nil {
		log.Fatalf("couldn't find reflow package: %v", err)
	}
	if err := ioutil.WriteFile(filepath.Join(pkg.Dir, "version.go"), versionFile(version, image), 0666); err != nil {
		log.Fatal(err)
	}
}

func command(name string, arg ...string) *exec.Cmd {
	cmd := exec.Command(name, arg...)
	if *vflag {
		cmd.Stderr = os.Stderr
		cmd.Stdout = os.Stdout
	}
	return cmd
}

var versionTmpl = template.Must(template.New("version").Parse(`// This file is automatically generated by releasereflow. Do not edit!

package main

const (
	version = "{{.Version}}"
	reflowlet = "{{.Reflowlet}}"
)
`))

func versionFile(version, reflowlet string) []byte {
	var (
		b    bytes.Buffer
		args = struct{ Version, Reflowlet string }{version, reflowlet}
	)
	if err := versionTmpl.Execute(&b, args); err != nil {
		log.Fatal(err)
	}
	return b.Bytes()
}
